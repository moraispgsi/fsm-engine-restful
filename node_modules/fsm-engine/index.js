/**
 * Created by Ricardo Morais on 12/04/2017.
 */

module.exports = function (dialect, host, user, password, database) {

    let co = require('co');
    let Sequelize = require('sequelize');
    let fsmCore = require('fsm-core')(dialect, host, user, password, database);
    let sequelize = fsmCore.sequelize;
    let scxml = require('scxml');
    let tablePrefix = "FsmEngine";
    let instanceStore = {};
    let SNAPSHOT_DELAY = 100;

    let model = {
        instance: sequelize.define(tablePrefix + 'Instance', {
            versionID: {type: Sequelize.INTEGER, allowNull: false},
            hasStarted: {type: Sequelize.BOOLEAN, allowNull: false, default: false},
            hasEnded: {type: Sequelize.BOOLEAN, allowNull: false, default: false}
        }, {
            freezeTableName: true,
            underscoredAll: false
        }),
        snapshot: sequelize.define(tablePrefix + 'Snapshot', {
            instanceID: {type: Sequelize.INTEGER, allowNull: false},
            snapshot: {type: Sequelize.TEXT, allowNull: false}
        }, {
            freezeTableName: true,
            underscoredAll: false
        }),
    };

    let meta = {
        sequelize: sequelize,
        model: model,
        fsmCore: fsmCore
    };

    model.instance.belongsTo(fsmCore.model.version, {
        foreignKey: 'versionID',
        constraints: false,
        onDelete: 'CASCADE'
    });

    model.snapshot.belongsTo(model.instance, {
        foreignKey: 'instanceID',
        constraints: false,
        onDelete: 'CASCADE'
    });

    //add the high level action to the scion interpreter scripting context
    require('./actions/highLevelActions')(scxml.scion.InterpreterScriptingContext.prototype);

    class Instance {

        constructor(sc, id) {
            this.sc = sc;
            this.id = id;
            instanceStore[this.id] = this;
        }

        _saveInstancePromise() {
            return co(function*() {
                yield model.snapshot.create({
                    instanceID: this.id,
                    snapshot: JSON.stringify(this.sc.getSnapshot())
                });
                console.log("Saved");
            }.bind(this));
        }

        startSnapshotInterval(){

            if(this.interval){
                clearInterval(this.interval);
            }
            this.interval = setInterval(function(){
                if(this.sc === null) {
                    clearInterval(interval);
                    return;
                }

                if(!this.sc._isStepping){
                    this._saveInstancePromise().then();
                }
            }.bind(this), SNAPSHOT_DELAY);

        }


        startPromise() {
            //todo - validate if the instance already started
            return co(function*() {

                yield model.instance.update({
                    hasStarted: true
                }, {
                    where: {
                        id: this.id
                    }
                });

                this.startSnapshotInterval();

                this.sc.start();

                yield this._saveInstancePromise();

            }.bind(this));

        }
    }

    function _makeStateChart(versionID, snapshot) {
        return co(function*() {
            try {

                //Make sure the version is sealed
                yield fsmCore.assert.assertVersionSealed(versionID);

                let version = yield fsmCore.model.version.findById(versionID);
                let scxmlDocumentString = version.dataValues.scxml;

                let model = yield new Promise((resolve, reject) => {
                    scxml.documentStringToModel(null, scxmlDocumentString, function (err, model) {
                        if (err) {
                            throw err;
                        }
                        resolve(model);
                    });
                }).then();

                let fnModel = yield new Promise((resolve, reject) => {
                    model.prepare(function (err, fnModel) {
                        if (err) {
                            throw err;
                        }
                        resolve(fnModel);
                    });
                }).then();

                console.log("SNAP:", snapshot)
                //instantiate the interpreter
                let sc = new scxml.scion.Statechart(fnModel, {snapshot : snapshot});

                return sc;

            } catch (error) {
                console.log(error);
            }
        });
    }

    function _makeInstance(versionID, sc) {
        return co(function*() {
            //start the interpreter
            let instanceRow = yield meta.model.instance.create({
                versionID: versionID,
                hasStarted: false,
                hasEnded: false
            });
            let instanceID = instanceRow.dataValues.id;
            let instance = new Instance(sc, instanceID);
            return instance;
        })
    }

    function makeInstancePromise(versionID) {
        return co(function*() {

            let sc = yield _makeStateChart(versionID);
            let instance = yield _makeInstance(versionID, sc);

            return instance;
        });
    }

    function getInstance(id) {
        if (!instanceStore[id]) {
            throw new Error("Instance not found");
        }
        return instanceStore[id];
    }

    return co(function*() {

        yield meta.sequelize.sync();

        let instances = yield model.instance.findAll({
            where: {
                hasEnded: false
            }
        });

        for (let instanceRow of instances) {
            let versionID = instanceRow.dataValues.versionID;
            //Make sure the version is sealed
            yield fsmCore.assert.assertVersionSealed(versionID);

            let version = yield fsmCore.model.version.findById(versionID);
            let scxmlDocument = version.dataValues.scxml;

            let latestSnapshot = yield meta.model.snapshot.findOne({
                where: {
                    instanceID: instanceRow.dataValues.id
                },
                order: [ [ 'updatedAt', 'DESC' ]]
            });

            let snapshot = latestSnapshot ? JSON.parse(latestSnapshot.dataValues.snapshot) : null;
            let sc = yield _makeStateChart(versionID, snapshot);
            let instance = new Instance(sc, instanceRow.dataValues.id);
            instance.startSnapshotInterval();

            instanceStore[instance.id] = instance;
        }

        return {
            meta: meta,
            makeInstancePromise: makeInstancePromise,
            getInstance: getInstance
        }
    });

};

