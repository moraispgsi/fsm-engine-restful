{
  "_args": [
    [
      {
        "raw": "scion-core@1.5.4",
        "scope": null,
        "escapedName": "scion-core",
        "name": "scion-core",
        "rawSpec": "1.5.4",
        "spec": "1.5.4",
        "type": "version"
      },
      "C:\\Users\\Ricardo Morais\\Desktop\\INSTICC\\PFC\\Projeto final\\FSM\\FSM Engine RESTful\\fsm-engine-restful\\node_modules\\scxml"
    ]
  ],
  "_from": "scion-core@1.5.4",
  "_id": "scion-core@1.5.4",
  "_inCache": true,
  "_location": "/scion-core",
  "_nodeVersion": "7.8.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/scion-core-1.5.4.tgz_1491776126432_0.6632859488017857"
  },
  "_npmUser": {
    "name": "jbeard",
    "email": "jbeard4@cs.mcgill.ca"
  },
  "_npmVersion": "4.2.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "scion-core@1.5.4",
    "scope": null,
    "escapedName": "scion-core",
    "name": "scion-core",
    "rawSpec": "1.5.4",
    "spec": "1.5.4",
    "type": "version"
  },
  "_requiredBy": [
    "/scxml"
  ],
  "_resolved": "https://registry.npmjs.org/scion-core/-/scion-core-1.5.4.tgz",
  "_shasum": "4b0ddf9a637ade285a4d125ad99c3edf8982730f",
  "_shrinkwrap": null,
  "_spec": "scion-core@1.5.4",
  "_where": "C:\\Users\\Ricardo Morais\\Desktop\\INSTICC\\PFC\\Projeto final\\FSM\\FSM Engine RESTful\\fsm-engine-restful\\node_modules\\scxml",
  "browser": "./dist/scion",
  "bugs": {
    "url": "https://github.com/jbeard4/SCION-CORE/issues",
    "email": "jbeard4@cs.mcgill.ca"
  },
  "dependencies": {},
  "description": "StateCharts Interpretation and Optimization eNgine (SCION) CORE is an implementation of Statecharts in JavaScript.",
  "devDependencies": {
    "async": "^1.5.2",
    "babel-plugin-transform-es2015-modules-umd": "^6.8.0",
    "babel-polyfill": "^6.9.1",
    "babel-preset-es2015": "^6.9.0",
    "ejs": "^2.4.2",
    "express": "^4.14.0",
    "grunt": "^1.0.1",
    "grunt-babel": "^6.0.0",
    "grunt-browserify": "^5.0.0",
    "grunt-contrib-nodeunit": "^1.0.0",
    "grunt-contrib-uglify": "^1.0.1",
    "grunt-express-server": "^0.5.3",
    "grunt-git": "^1.0.0",
    "grunt-release": "^0.14.0",
    "grunt-saucelabs": "9.0.0",
    "load-grunt-tasks": "^3.5.0",
    "minimist": "^1.2.0",
    "nodeunit": "^0.9.1",
    "tape": "^4.6.0",
    "underscore": "^1.8.3"
  },
  "directories": {},
  "dist": {
    "shasum": "4b0ddf9a637ade285a4d125ad99c3edf8982730f",
    "tarball": "https://registry.npmjs.org/scion-core/-/scion-core-1.5.4.tgz"
  },
  "engines": {
    "node": ">=4.2.2"
  },
  "gitHead": "4232acafb7b942fa56958a32e0b1724f3b341a8c",
  "homepage": "https://github.com/jbeard4/SCION-CORE#readme",
  "keywords": [
    "scxml",
    "statecharts",
    "w3c",
    "javascript"
  ],
  "license": "Apache-2.0",
  "main": "./lib/scion",
  "maintainers": [
    {
      "name": "Jacob Beard",
      "email": "jbeard4@cs.mcgill.ca"
    }
  ],
  "name": "scion-core",
  "optionalDependencies": {},
  "readme": "\n# Overview\n\nSCION-CORE is a small implementation of Statecharts in ECMAScript (JavaScript). SCION-CORE lets you program with Statecharts using a simple JavaScript/JSON API. \n\n# Installation\n\n## Browser\n\nInstall via bower:\n\n```\nnpm install -g bower\nbower install scion-core\n```\n\nAdd to your page:\n\n`<script src=\"bower_components/scion-core/dist/scion.min.js\"></script>`\n\nSCION-CORE is then available as the global variable `scion`.\n\nAlternatively, load SCION-CORE via RequireJS:\n\n```html\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js\"></script>\n  <script>\n    require(['/bower_components/scion-core/dist/scion.min.js'], function(){\n    }); \n  </script>\n```\n\n## Node.js\n\nInstall SCION-CORE via npm:\n\n    npm install scion-core\n\n# API\n\n## new scion.Statechart(model)\n\nThe SCXML constructor creates an interpreter instance from a model object.\n\n```javascript\n    //same model can be used to create multiple interpreter instances\n    var sc1 = new scion.Statechart(model),\n        sc2 = new scion.Statechart(model);\n```\n\n## sc.start() : `<String>`[]\n\n`sc.start` starts the SCION-CORE interpreter. `sc.start` should only be called once, and should be called before `sc.gen` is called for the first time.\n\nReturns a \"basic configuration\", which is an Array of strings representing the ids all of the basic states the interpreter is in after the call to `sc.start` completes.\n\n## sc.gen(String eventName, Object eventData) : `<String>`[]\n## sc.gen({name : String, data : Object}) : `<String>`[]\n\nAn SCXML interpreter takes SCXML events as input, where an SCXML event is an object with \"name\" and \"data\" properties. These can be passed to method `gen` as two positional arguments, or as a single object.\n\n`sc.gen` returns a \"basic configuration\", which is an Array of strings representing the ids all of the basic states the interpreter is in after the call to `sc.gen` completes.\n\n```javascript\n    var sc = new scion.Statechart(model),\n\n    var data = {foo:1};\n    var configuration = sc.gen(\"eventName\",data); \n\n    //the following call is equivalent\n    var configuration = sc.gen({name:\"eventName\",data:{foo:1}}); \n```\n\n## Event Emitter\n\nSCION-CORE includes the [tiny-events](https://github.com/ZauberNerd/tiny-events) library, and implements the following EventEmitter methods:\n\n* on(type: string, listener: Function): EventEmitter\n* once(type: string, listener: Function): EventEmitter\n* off(type: string, listener?: Function): EventEmitter\n* emit(type: string, ...args: any[]): EventEmitter\n\nSCION-CORE emits the following events:\n\n* onEntry\n* onExit\n* onTransition\n* onBigStepBegin\n* onBigStepSuspend\n* onBigStepResume\n* onSmallStepBegin\n* onSmallStepEnd\n* onBigStepEnd\n* onError\n\nThe `onError` callback receives an object containing the following properties:\n\n* `tagname` - The name of the element that produced the error. \n* `line` - The line in the source file in which the error occurred.\n* `column` - The column in the source file in which the error occurred.\n* `reason` - An informative error message. The text is platform-specific and subject to change.\n\n## sc.registerListener({onEntry : function(stateId){}, onExit : function(stateId){}, onTransition : function(sourceStateId,[targetStateIds,...]){}, onError: function(errorInfo){}})\n\nThis is an alternative interface to `on`.\n\n## sc.getConfiguration() : String[]\n\nReturns current state machine ***configuration***, the set of basic states in which the state machine resides. \n\n## sc.getFullConfiguration() : String[]\n\nReturns current state machine ***full configuration***, the set of basic states in which the state machine resides, and the hierarchical ancestors of those basic states. \n\n## sc.isIn(String : stateId) : Boolean\n\nReturns true if the state machine is in state with id `stateId`.\n\n## sc.isFinal() : Boolean\n\nReturns true, if the state machine is in a final state. Otherwise, returns false. \n\n## sc.getSnapshot() : Snapshot \n\nReturns a `snapshot` object, of the form : \n\n```\n[\n    configuration,\n    history,\n    isInFinalState,\n    dataModel\n]\n```\n\nThe snapshot object can be serialized as JSON and saved to a database. It can later be passed to the SCXML constructor to restore the state machine: `new scion.Statechart(model, {snapshot : snapshot})`.\n\n# Statecharts Model Schema\n\nSCION-CORE is designed to allow you to specify the Statecharts model declaratively as a single JavaScript object literal, or as JSON. This section is intended to describe the schema of the Statecharts object model accepted by SCION-CORE. \n\nThis section will also touch briefly on semantics, but is not meant to serve as a comprehensive reference.  Unlike SCXML.js, a formal semantics has not been defined for SCION-CORE. However it is very close to [Rhapsody Semantics](http://research.microsoft.com/pubs/148761/Charts04.pdf).\n\n## States\n\nA SCION-CORE model is made up of states. States can have id's, which are optional. Here is a SCION-CORE model which is a single state:\n\n```\n{\n    id : 'foo'\n}\n```\n\nStates can contain other states hierarchically:\n\n```javascript\n{\n    id : 'foo'\n    states : [\n        {\n            id : 'bar'\n        },\n        {\n            id : 'bat'\n        }\n    ]\n}\n```\n\nBy default, a parent state will be an \"OR\" state, which means it defines an XOR relationship between its children (if the state machine is in 'foo', then the state machine will either be in state 'bar' or 'bat', but will never be in both 'bar' and 'bat' simultaneously). \n\nBy default, when entering a parent state, the first state in the parent's state array will be entered. So, for example, when the state machine is started with the above model, its **configuration** (the set of states the state machine is currently in) will be `['foo','bar']`;\n\nThere are other types of states, however, including \"parallel\" states, which defines an \"AND\" relationship between substates.\n\n```javascript\n{\n    id : 'foo'\n    $type : 'parallel'\n    states : [\n        {\n            id : 'bar'\n        },\n        {\n            id : 'bat'\n        }\n    ]\n}\n```\n\nIn this example, if the state machine is in state 'foo', then the state machine will also be in state 'bar' and state 'bat' simultaneously. So when the state machine is started with the above model, its configuration will be `['foo','bar','bat']`.\n\n## Transitions\n\nStates are associated with **transitions**, which target other states. Transitions are optionally associated with an **event name**. A SCION-CORE event is an object with \"name\" and \"data\" properties. When an event is sent to the state machine, the interpreter will inspect the current configuration, and select the set of transitions that matches event name.\n\n\n```javascript\n{\n    id : 'foo'\n    states : [\n        {\n            id : 'bar',\n            transitions : [\n                {\n                    target : 'bat',\n                    event : 't'\n                }\n            ]\n        },\n        {\n            id : 'bat'\n        }\n    ]\n}\n```\n\nIn this case, the state machine would start in configuration `['foo','bar']`. When event `{ name : 't' }` is sent to the state machine, then the state machine would transition to state 'bat', and the resulting configuration would be `['foo','bat']`.\n\nIf the transition does not have an event property, then it is known as a \"default transition\", and it will be selected regardless of the event's \"name\" property.\n\nA transition can also be associated with a **condition**, which is an arbitrary JavaScript function that accepts an event as input, and returns a boolean value as output. Boolean true means the transition can be selected, while boolean false means the transition will not be selected.\n\n```javascript\n{\n    id : 'foo'\n    states : [\n        {\n            id : 'bar',\n            transitions : [\n                {\n                    target : 'bat',\n                    event : 't',\n                    cond : function(event){\n                        return event.data % 2;\n                    }\n                }\n            ]\n        },\n        {\n            id : 'bat'\n        }\n    ]\n}\n```\n\nFor example, the above model will only transition from 'bar' to 'bat', when `event.data` contains an odd number.\n\n## Entry, Exit, and Transition Actions\n\nStates can be associated with **entry** and **exit** actions. These are JavaScript functions which are executed when the state is entered or exited.\n\nTransitions can also be associated with actions.\n\nActions are executed in the following order: \n\n* State exit actions, ordered first by hierarchy (inner states first), and then by the order in which they appear in the document.\n* Transition actions, based on document order.\n* State entry actions, ordered first by hierarchy (outer states first), and then by the order in which they appear in the document.\n\n```javascript\nvar buffer;\n\nvar model = {\n    id : 'foo'\n    onEntry : function(event){\n        buffer = [];      //initialize array\n    },\n    states : [\n        {\n            id : 'bar',\n            onEntry : function(event){\n                buffer.push(1);\n            },\n            onExit : function(event){\n                buffer.push(2);\n            },\n            transitions : [\n                {\n                    target : 'bat',\n                    event : 't',\n                    onTransition : function(event){\n                        buffer.push(3);\n                    }\n                }\n            ]\n        },\n        {\n            id : 'bat',\n            onEntry : function(event){\n                buffer.push(event.data);\n            }\n        }\n    ]\n};\n\nvar sc = new scion.Statechart(model);\nsc.start();     //buffer now contains [1]\nsc.gen('t','x');    //buffer now contains [1,2,3,'x']\n```\n\nFor the above model, when the state machine is started, 'foo' would be entered, thus initializing variable `buffer` with a new array; and then state 'bar' would be entered, pushing `1` to the buffer. After the invocation to `sc.start`, the buffer would then container `[1]`.\n\nDuring the call to `sc.gen`, the exit action of state 'bar' would be executed, pushing `2` to the buffer, followed by transition action, pushing `3` to the buffer, followed by the entry action of `bat`, pushing the event data, string `\"x\"`, to the buffer. After the call to `sc.gen` completes, the buffer would contain [1,2,3,'x'].\n\n## History\n\nA **history** state is a special pseudo-state that allows the state machine to \"remember\" what substate it was in last time it was in a particular parent state. There are two types of history states: \"deep\" and \"shallow\".\n\nThe syntax for specifying history states is as follows:\n\n```javascript\n{\n    states : [\n        {\n            id : 'foo',\n            transitions : [\n                { \n                    event : 't2'\n                    target : 'bif'\n                }\n            ],\n            states : [\n                {\n                    id : 'h',\n                    $type : 'history',\n                    isDeep : true\n                    transitions : [\n                        {\n                            target : 'bar'\n                        }\n                    ]\n                },\n                {\n                    id : 'bar',\n                    transitions : [\n                        { \n                            event : 't1'\n                            target : 'bat2'\n                        }\n                    ]\n                },\n                {\n                    id : 'bat',\n                    substates : [\n                        {\n                            id : 'bat1'\n                        },\n                        {\n                            id : 'bat2'\n                        }\n                    ]\n                }\n            ]\n        },\n        {\n            id : 'bif',\n            transitions : [\n                {\n                    target : 'h',\n                    event : 't3'\n                }\n            ]\n        }\n    ]\n}\n```\n\nThe first time the state machine enters 'h', it it will transition to state 'bar'. After the call to sc.start(), the state machine will reside in ['foo','bar'].\n\nAfter the state machine sends event `t1`, the state machine will transition to 'bat2', and will reside in configuration `['foo','bat','bat2']`.\n\nAfter the state machine sends event `t2`, the state machine will transition to 'bif', and will reside in configuration `['bif']`.\n\nFinally, after the state machine sends event `t3`, the state machine will transition to back to the history state 'h', which will \"remember\", the configuration the state machine was in last time it was in 'foo', and the state machine will complete in configuration `['foo','bat','bat2']`.\n\nIf property `isDeep` had not been set on the history state, then the state machine would only have remembered the child substates of `foo`, and the state machine would have completed in configuration `['foo','bat','bat1']`.\n\n## Communications\n\nThe context object (\"`this`\") of onEntry, onExit, and onTransition functions contains the following methods:\n\n* `send(event)`, which adds an event to the Statechart's outer queue\n* `raise(event)`, which adds an event to the Statechart's inner queue \n\n\n\n# Quickstart and Simple Use Case\n\nLet's start with the simple example of drag-and-drop behaviour in the browser. You can run this demo live on jsfiddle [here](http://jsfiddle.net/jbeard4/MDkLe/11/).\n\nAn entity that can be dragged has two states: idle and dragging. If the entity is in an idle state, and it receives a mousedown event, then it starts dragging. While dragging, if it receives a mousemove event, then it changes its position. Also while dragging, when it receives a mouseup event, it returns to the idle state.\n\nThis natural-language description of behaviour can be described using the following simple state machine:\n\n![Drag and Drop](http://jbeard4.github.com/SCION/img/drag_and_drop.png)\n\nThis state machine could be written in SCION-CORE's JSON syntax as follows:\n\n```javascript\n{\n    \"states\" : [\n        {\n            \"id\" : \"idle\",\n            \"transitions\" : [\n                {\n                    \"event\" : \"mousedown\",\n                    \"target\" : \"dragging\",\n                }\n            ]\n        },\n        {\n            \"id\" : \"dragging\",\n            \"transitions\" : [\n                {\n                    \"event\" : \"mouseup\",\n                    \"target\" : \"idle\",\n                },\n                {\n                    \"event\" : \"mousemove\",\n                    \"target\" : \"dragging\"\n                }\n            ]\n        }\n    ]\n}\n```\n\nOne can add action code in order to script an HTML DOM element, so as to change its position on mousemove events:\n\n```javascript\n//declare the your statechart model, same as before\nvar firstEvent,\n    eventStamp,\n    rectNode = document.getElementById('rect'),\n    rectX = 0,\n    rectY = 0;\n\nvar statechartModel = {\n    states : [\n        {\n            id : 'idle',\n            onEntry : function(){\n                rectNode.textContent='idle';\n            },\n            transitions : [\n                {\n                    event : 'mousedown',\n                    target : 'dragging',\n                    onTransition : function(event){\n                        eventStamp = firstEvent = event.data;\n                    }\n                }\n            ]\n        },\n        {\n            id : 'dragging',\n            onEntry : function(){\n                rectNode.textContent='dragging';\n            },\n            transitions : [\n                {\n                    event : 'mouseup',\n                    target : 'idle'\n                },\n                {\n                    event : 'mousemove',\n                    target : 'dragging',\n                    onTransition : function(event){\n                        var dx = eventStamp.clientX - event.data.clientX;\n                        var dy = eventStamp.clientY - event.data.clientY;\n\n                        rectNode.style.left = (rectX -= dx) + 'px';\n                        rectNode.style.top = (rectY -= dy) + 'px';\n                        \n                        eventStamp = event.data;\n                    }\n                }\n            ]\n        }\n    ]\n};\n```\n\nYou can then perform the following steps to script web content:\n\n1. Use the statecharts model object to instantiate the SCXML interpreter.\n2. Connect relevant event listeners to the SCXML interpreter.\n3. Call the `start` method on the SCXML interpreter to start execution of the statechart.\n\n\n```html\n<html>\n    <head>\n        <script src=\"http://cdnjs.cloudflare.com/ajax/libs/es5-shim/1.2.4/es5-shim.min.js\"></script>\n        <script src=\"bower_components/scion-core/dist/scion.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"rect\"/>\n        <script>\n            //declare the your statechart model, same as before\n            var firstEvent,\n                eventStamp,\n                rectNode = document.getElementById('rect'),\n                rectX = 0,\n                rectY = 0;\n\n            var statechartModel = {\n                states : [\n                    {\n                        id : 'idle',\n                        onEntry : function(){\n                            rectNode.textContent='idle';\n                        },\n                        transitions : [\n                            {\n                                event : 'mousedown',\n                                target : 'dragging',\n                                onTransition : function(event){\n                                    eventStamp = firstEvent = event.data;\n                                }\n                            }\n                        ]\n                    },\n                    {\n                        id : 'dragging',\n                        onEntry : function(){\n                            rectNode.textContent='dragging';\n                        },\n                        transitions : [\n                            {\n                                event : 'mouseup',\n                                target : 'idle'\n                            },\n                            {\n                                event : 'mousemove',\n                                target : 'dragging',\n                                onTransition : function(event){\n                                    var dx = eventStamp.clientX - event.data.clientX;\n                                    var dy = eventStamp.clientY - event.data.clientY;\n\n                                    rectNode.style.left = (rectX -= dx) + 'px';\n                                    rectNode.style.top = (rectY -= dy) + 'px';\n                                    \n                                    eventStamp = event.data;\n                                }\n                            }\n                        ]\n                    }\n                ]\n            };\n\n            //instantiate the interpreter\n            var interpreter = new scion.Statechart(statechartModel);\n\n            //start the interpreter\n            interpreter.start();\n\n            function handleEvent(e){\n                e.preventDefault();\n                interpreter.gen({name : e.type,data: e});\n            }\n\n            //connect all relevant event listeners\n            rectNode.addEventListener('mousedown',handleEvent,true);\n            document.documentElement.addEventListener('mouseup',handleEvent,true);\n            document.documentElement.addEventListener('mousemove',handleEvent,true);\n\n\n        </script>\n    </body>\n</html>\n```\n\n\n\n\n# Build Status\n\n[![Build status](https://travis-ci.org/jbeard4/SCION-CORE.svg?branch=master)](https://travis-ci.org/jbeard4/SCION-CORE)\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jbeard4/SCION-CORE.git"
  },
  "scripts": {
    "build": "grunt build",
    "test": "grunt test"
  },
  "version": "1.5.4"
}
