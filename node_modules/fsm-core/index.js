/**
 * Created by Ricardo Morais on 25/02/2017.
 */

module.exports = function (dialect, host, user, password, database) {
    let co = require('co');
    let Sequelize = require('sequelize');
    let ioCore = require('io-core')(dialect, host, user, password, database);
    let sequelize = ioCore.sequelize;
    let tablePrefix = 'FSMCore';
    let meta = {
        sequelize: sequelize,
        name: 'fsm-core',
        dependencies: {
            ioCore: ioCore,
        },
        model: {
            fsm: sequelize.define(tablePrefix + 'Fsm', {
                name: {type: Sequelize.STRING, allowNull: false, unique: true},
            }, {
                freezeTableName: true,
                underscoredAll: false
            }),
            version: sequelize.define(tablePrefix + 'version', {
                isSealed: {type: Sequelize.BOOLEAN, allowNull: false, defaultValue: false},
                scxml: {type: Sequelize.TEXT, allowNull: true}
            }, {
                freezeTableName: true,
                underscoredAll: false
            }),
            state: sequelize.define(tablePrefix + 'state', {
                name: {type: Sequelize.STRING, allowNull: false, unique: 'stateVersion'},
                versionID: {type: Sequelize.INTEGER, allowNull: false, unique: 'stateVersion'},
            }, {
                freezeTableName: true,
                underscoredAll: false
            }),
            transition: sequelize.define(tablePrefix + 'transition', {
                fromID: {type: Sequelize.INTEGER, allowNull: false, unique: 'transitionState'},
                toID: {type: Sequelize.INTEGER, allowNull: false, unique: 'transitionState'},
            }, {
                freezeTableName: true,
                underscoredAll: false
            }),
            transitionInput: sequelize.define(tablePrefix + 'transitionInput', {
                transitionID: {type: Sequelize.INTEGER, allowNull: false, unique: true},
                inputID: {type: Sequelize.INTEGER, allowNull: false},
            }, {
                freezeTableName: true,
                underscoredAll: false
            }),
            onEnter: sequelize.define(tablePrefix + 'OnEnter', {
                stateID: {type: Sequelize.INTEGER, allowNull: false, unique: 'onEnter'},
                actionCallID: {type: Sequelize.INTEGER, allowNull: false, unique: 'onEnter'},
            }, {
                freezeTableName: true,
                underscoredAll: false
            }),
            onExit: sequelize.define(tablePrefix + 'OnExit', {
                stateID: {type: Sequelize.INTEGER, allowNull: false, unique: 'onExit'},
                actionCallID: {type: Sequelize.INTEGER, allowNull: false, unique: 'onExit'},
            }, {
                freezeTableName: true,
                underscoredAll: false
            }),
            onTransition: sequelize.define(tablePrefix + 'OnTransition', {
                transitionID: {type: Sequelize.INTEGER, allowNull: false, unique: 'onTransition'},
                actionCallID: {type: Sequelize.INTEGER, allowNull: false, unique: 'onTransition'},
            }, {
                freezeTableName: true,
                underscoredAll: false
            }),
        },
        assert: {
            assertVersionNotSealed: (versionID) => {

                return new Promise((resolve, reject) => {
                    meta.model.version.findById(versionID).then((version) => {

                        if (!version) {
                            reject('version not found');
                            return;
                        }

                        if (version.dataValues.isSealed) {
                            reject('version is sealed');
                            return;
                        }

                        resolve(version);

                    });
                });

            },
            assertVersionSealed: (versionID) => {

                return new Promise((resolve, reject) => {

                    meta.model.version.findById(versionID)
                        .then((version) => {

                            if (!version) {
                                //throw 'version not found';
                                reject('version not found');
                                return;
                            }

                            if (!version.dataValues.isSealed) {
                                //throw 'version is not sealed';
                                reject('version is not sealed');
                                return;
                            }

                            resolve(version);

                        });
                });

            },
            assertStateVersionNotSealed: (stateID) => {
                return new Promise((resolve, reject) => {
                    meta.model.state.findById(stateID)
                        .catch(() => reject('state not found'))
                        .then((state) => {
                            meta.assert.assertVersionNotSealed(state.dataValues.versionID)
                                .catch((err) => reject(err))
                                .then(() => resolve())
                        });
                });

            },
            assertTransitionVersionNotSealed (transitionID){
                return new Promise((resolve, reject) => {
                    meta.model.transition
                        .findById(transitionID)
                        .catch(() => reject('transition not found'))
                        .then((transition) => {
                            meta.assert
                                .assertStateVersionNotSealed(transition.dataValues.fromID)
                                .catch((err) => reject(err))
                                .then(() => resolve());
                        });
                });
            }
        },
        get: {
            isVersionSealed: (versionID) => {
                return new Promise((resolve, reject) => {
                    meta.model.version.findById(versionID).then((version) => {

                        if (!version) {
                            reject('version not found');
                            return;
                        }

                        resolve(version.dataValues.isSealed);

                    });
                });
            },
            versionTransitions: (versionID) => {
                return new Promise((resolve, reject) => {
                    meta.model.transition.findAll({
                        where: Sequelize.where(Sequelize.col('transitionFromState.versionID'), versionID),
                        include: [
                            {
                                model: meta.model.state,
                                as: 'transitionFromState'
                            },
                            {
                                model: meta.model.state,
                                as: 'transitionToState'
                            }
                        ]
                    }).then((transitions) => {
                        resolve(transitions);
                    });
                });
            },
            getActionCallScript(actionCallID){
                return co(function*() {
                    let actionCall = yield ioCore.query.getActionCall(actionCallID);
                    let action = yield ioCore.query.getAction(actionCall.dataValues.actionID);
                    let actionCallScript = action.dataValues.name + "(";
                    let actionValues = yield ioCore.query.getActionCallValues(actionCallID);

                    actionCallScript += "context, ";

                    if(actionValues){
                        actionCallScript += "{";
                    }

                    for (let value of actionValues) {
                        let parameter = yield ioCore.model.parameter.findById(value.dataValues.parameterID);
                        //todo - cast to the parameter type
                        actionCallScript += parameter.dataValues.name + ": " + value.dataValues.value + ", ";
                    }
                    actionCallScript = actionCallScript.replace(/,\s*$/, "");
                    if(actionValues){
                        actionCallScript += "}";
                    }
                    actionCallScript += ")";
                    return actionCallScript;
                });
            }

        },
        action: {
            createFSM: function (name) {
                //out FSMID, out VersionID
                return sequelize.transaction(function (t) {
                    return co(function*() {
                        let fsm = yield meta.model.fsm.create({name: name}, {transaction: t});
                        let version = yield meta.model.version.create({fsmID: fsm.dataValues.id}, {transaction: t});
                        return {fsm: fsm, version: version};
                    });
                });
            },
            createState: function (name, versionID) {
                // out StateID
                return co(function*() {
                    yield meta.assert.assertVersionNotSealed(versionID)
                    let state = yield meta.model.state.create({name: name, versionID: versionID});
                    return state;
                });
            },
            createTransition: function (fromID, toID) {
                // out TransitionID
                return sequelize.transaction(function (t) {
                    return co(function*() {
                        let fromState = yield meta.model.state.findById(fromID);
                        let toState = yield meta.model.state.findById(toID);
                        if (fromState.dataValues.versionID !== toState.dataValues.versionID) {
                            throw new Error('Versions do not match');
                        }
                        let versionID = fromState.dataValues.versionID;
                        yield meta.assert.assertVersionNotSealed(versionID);
                        let transition = yield meta.model.transition.create({fromID: fromID, toID: toID});
                        return transition;
                    });
                });
            },
            removeFSMModel: function (fsmID) {
                return co(function*() {
                    let fsm = yield meta.model.fsm.findById(fsmID);
                    if (!fsm) {
                        throw new Error('FSM not found');
                    }
                    let versions = yield meta.model.version.findAll({where: {fsmID: fsm.dataValues.id}});
                    if (versions.length > 1) {
                        throw new Error('FSM has more than one version');
                    }
                    //Fms has at least one version therefor the array has one version
                    if (versions[0].dataValues.isSealed) {
                        throw new Error('fsm version is sealed');
                    }
                    //Cascade deletion
                    yield fsm.destroy();
                });
            },
            removeFSMModelVersion: function (versionID) {
                return co(function*() {
                    let version = yield meta.model.version.findById(versionID);
                    if (!version) {
                        throw new Error('version not found');
                    }
                    if (version.dataValues.isSealed) {
                        throw new Error('fsm version is sealed');
                    }

                    let fsm = meta.model.fsm.findOne({
                        where: {
                            id: version.dataValues.fsmID
                        }
                    });
                    //If the fsm has only one version, the fsm  must be removed
                    version.destroy();
                    let count = yield meta.model.version.count({where: {id: versionID}});
                    //There is only one version and the version is not sealed
                    if (count === 0) {
                        fsm.destroy();
                    }

                });
            },
            removeState: function (stateID) {
                return co(function*() {
                    yield meta.assert.assertStateVersionNotSealed(stateID);
                    let state = yield meta.model.state.findById(stateID);
                    state.destroy();
                });
            },
            removeTransition: function (transitionID) {
                return co(function*() {
                    yield meta.assert.assertTransitionVersionNotSealed(transitionID);
                    let transition = yield meta.model.transition.findById(transitionID);
                    transition.destroy();
                });
            },
            setInitialState: function (stateID) {
                return co(function*() {
                    yield meta.assert.assertStateVersionNotSealed(stateID);
                    let state = yield meta.model.state.findById(stateID);
                    yield meta.model.version.update({
                        initialStateID: stateID,
                    }, {
                        where: {id: state.dataValues.versionID}
                    });
                });
            },
            unsetInitialState: function (versionID) {
                return co(function*() {
                    yield meta.assert.assertVersionNotSealed(versionID);
                    yield meta.model.version.update({
                        initialStateID: null,
                    }, {
                        where: {id: versionID}
                    });
                });
            },
            seal: function (versionID) {
                return co(function*() {
                    let version = yield meta.assert.assertVersionNotSealed(versionID);
                    if (version.dataValues.initialStateID === null) {
                        throw new Error('version must have a initial state');
                    }

                    //Generate SCXML
                    let states = yield meta.model.state.findAll({
                        where: {
                            versionID: versionID
                        }
                    });

                    let builder = require('./configuration-builder');
                    let initialState = yield meta.model.state.findById(version.dataValues.initialStateID);
                    builder.setInitialState(initialState.dataValues.name);

                    for (let state of states) {

                        builder.addState(state.dataValues.name);

                        let onEntry = yield meta.model.onEnter.findOne({
                            where: {
                                stateID: state.dataValues.id
                            }
                        });

                        let onExit = yield meta.model.onExit.findOne({
                            where: {
                                stateID: state.dataValues.id
                            }
                        });

                        if(onEntry) {
                            builder.onEnter(state.dataValues.name, yield meta.get.getActionCallScript(onEntry.dataValues.actionCallID));
                        }

                        if(onExit) {
                            builder.onExit(state.dataValues.name, yield meta.get.getActionCallScript(onExit.dataValues.actionCallID));
                        }

                    }
                    let scxml = builder.build({
                        pretty: true,
                        indent: '  ',
                        newline: '\n',
                        allowempty: false
                    });


                    yield meta.model.version.update({
                            isSealed: true,
                            scxml: scxml
                        }, {
                            where: {id: versionID}
                        }
                    );

                });
            },
            bindInputToTransition: function (inputID, transitionID) {
                return co(function*() {
                    yield meta.assert.assertTransitionVersionNotSealed(transitionID);
                    let count = yield meta.model.transitionInput.count({
                        where: {
                            transitionID: transitionID
                        }
                    });
                    if (count > 0) {
                        throw new Error('There is already a binding to this transition');
                    }
                    yield meta.model.transitionInput.create({
                        transitionID: transitionID,
                        inputID: inputID
                    });
                });
            },
            onTransition: function (actionCallID, transitionID) {
                return co(function*() {
                    yield meta.assert.assertTransitionVersionNotSealed(transitionID);
                    yield meta.model.onTransition.create({
                        transitionID: transitionID,
                        actionCallID: actionCallID
                    });
                });
            },
            onEnter: function (actionCallID, stateID) {
                return co(function*() {
                    yield meta.assert.assertStateVersionNotSealed(stateID);
                    yield meta.model.onEnter.create({
                        stateID: stateID,
                        actionCallID: actionCallID
                    });
                });
            },
            onExit: function (actionCallID, stateID) {
                return co(function*() {
                    yield meta.assert.assertStateVersionNotSealed(stateID);
                    yield meta.model.onExit.create({
                        stateID: stateID,
                        actionCallID: actionCallID
                    });
                });
            },
            unbindInputToTransition: function (inputID, transitionID) {
                return co(function*() {
                    yield meta.assert.assertTransitionVersionNotSealed(transitionID);
                    let bond = yield meta.model.TransitionInput.findOne({
                        where: {
                            transitionID: transitionID,
                            inputID: inputID
                        }
                    });
                    yield bond.destroy();
                });
            },
            removeOnTransition: function (actionCallID, transitionID) {
                return co(function*() {
                    yield meta.assert.assertTransitionVersionNotSealed(transitionID);
                    let bond = yield meta.model.onTransition.findOne({
                        where: {
                            transitionID: transitionID,
                            actionCallID: actionCallID
                        }
                    });
                    yield bond.destroy();
                });
            },
            removeOnEnter: function (actionCallID, stateID) {
                return co(function*() {
                    yield meta.assert.assertStateVersionNotSealed(stateID);
                    let bond = yield meta.model.onEnter.findOne({
                        where: {
                            stateID: stateID,
                            actionCallID: actionCallID
                        }
                    });
                    yield bond.destroy();
                });
            },
            removeOnExit: function (actionCallID, stateID) {
                return co(function*() {
                    yield meta.assert.assertStateVersionNotSealed(stateID);
                    let bond = yield meta.model.onExit.findOne({
                        where: {
                            stateID: stateID,
                            actionCallID: actionCallID
                        }
                    });
                    yield bond.destroy();
                });
            },

            //todo create this function
            cloneFSMModel: function (versionID) {
                // out FSMID, out VersionID
                return new Promise((resolve, reject) => {
                    //create states
                    //create transitions
                    //create bonds
                });
            },
            //todo redo this function using co library
            refurbishFSMModelVersion: function (versionID) {
                // out VersionID
                /*
                 return new Promise((resolve, reject) => {

                 //check if version is sealed, if the version is sealed copy all
                 let newVersion;
                 meta.assert
                 .assertVersionSealed(versionID)
                 .then((version) => {
                 console.log("HEREEEEE");

                 return meta.model.version.create({
                 fsmID: version.dataValues.fsmID,
                 versionParentForkID: versionID
                 });
                 })
                 .catch((err) => {
                 return Promise.reject(err);
                 })
                 .then((version) => {
                 newVersion = version;
                 //create states
                 return meta.model.state.findAll({
                 where: {
                 versionID: versionID
                 }
                 });
                 })
                 .catch((err) => {
                 return Promise.reject(err);
                 })
                 .then((states) => {
                 let promises = [];
                 for (let state of states) {
                 promises
                 .push(meta.action.createState(state.dataValues.name, newVersion.dataValues.id));
                 }
                 return Promise.all(promises).then(() => {
                 return meta.get.versionTransitions(versionID);
                 });
                 })
                 .catch((err) => {
                 return Promise.reject(err);
                 })
                 .then((transitions) => {
                 let promises = [];
                 for (let transition of transitions) {
                 promises.push(new Promise((resolve, reject) => {
                 let fromStateName = transition.dataValues.transitionFromState.dataValues.name;
                 let toStateName = transition.dataValues.transitionToState.dataValues.name;
                 let fromState;
                 let toState;
                 meta.model.state.findOne({
                 where: {
                 versionID: newVersion.dataValues.id,
                 name: fromStateName
                 }
                 }).then((data) => {
                 fromState = data;
                 return meta.model.state.findOne({
                 where: {
                 versionID: newVersion.dataValues.id,
                 name: toStateName
                 }
                 });
                 }).then((data) => {
                 toState = data;
                 return meta.action
                 .createTransition(fromState.dataValues.id, toState.dataValues.id);
                 }).then((transition) => {
                 resolve(newVersion);
                 });
                 }));
                 }
                 Promise.all(promises).then(() => {
                 return meta.get.versionStateOutputBond(versionID)
                 }).then((rows) => {
                 let promises = [];
                 for (let row of rows) {
                 promises.push(new Promise((resolve, reject) => {
                 meta.model.state.findOne({
                 where: {
                 versionID: newVersion.dataValues.id,
                 name: row.dataValues
                 .stateFK
                 .dataValues.name
                 }
                 }).then((state) => {

                 meta.action.bindOutputToState(row.dataValues.outputID, state.dataValues.id)
                 .then(() => resolve());
                 });
                 }));
                 }
                 return Promise.all(promises);
                 }).then(() => {
                 return meta.get.versionTransitionInputBond(versionID)
                 }).then((rows) => {
                 let promises = [];

                 for (let row of rows) {
                 promises.push(new Promise((resolve, reject) => {
                 let _transition;
                 let _fromStateName;
                 let _toStateName;
                 let _newFromState;
                 let _newToState;
                 meta.model.transition.findById(row.dataValues.transitionID)
                 .then((transition) => {
                 _transition = transition;
                 return meta.model.state.findById(_transition.dataValues.fromID);
                 }).then((fromState) => {
                 _fromStateName = fromState.dataValues.name;
                 return meta.model.state.findById(_transition.dataValues.toID);
                 }).then((toState) => {
                 _toStateName = toState.dataValues.name;
                 return meta.model.state.findOne({
                 where: {
                 name: _fromStateName,
                 versionID: newVersion.dataValues.id
                 }
                 });
                 }).then((fromState) => {
                 _newFromState = fromState;
                 return meta.model.state.findOne({
                 where: {
                 name: _toStateName,
                 versionID: newVersion.dataValues.id
                 }
                 });
                 }).then((toState) => {
                 _newToState = toState;

                 return meta.model.transition.findOne({
                 where: {
                 fromID: _newFromState.dataValues.id,
                 toID: _newToState.dataValues.id
                 }
                 });
                 }).then((transition) => {
                 meta.query
                 .action
                 .bindInputToTransition(row.dataValues.inputID, transition.dataValues.id)
                 .then(() => resolve());
                 });
                 }));

                 }
                 return Promise.all(promises);
                 }).then(() => {

                 return meta.get.versionTransitionOutputBond(versionID);
                 }).then((rows) => {
                 let promises = [];
                 for (let row of rows) {
                 promises.push(new Promise((resolve, reject) => {
                 let _transition;
                 let _fromStateName;
                 let _toStateName;
                 let _newFromState;
                 let _newToState;
                 meta.model.transition.findById(row.dataValues.transitionID)
                 .then((transition) => {
                 _transition = transition;
                 return meta.model.state.findById(_transition.dataValues.fromID);
                 }).then((fromState) => {
                 _fromStateName = fromState.dataValues.name;
                 return meta.model.state.findById(_transition.dataValues.toID);
                 }).then((toState) => {
                 _toStateName = toState.dataValues.name;

                 return meta.model.state.findOne({
                 where: {
                 name: _fromStateName,
                 versionID: newVersion.dataValues.id
                 }
                 });
                 }).then((fromState) => {
                 _newFromState = fromState;

                 return meta.model.state.findOne({
                 where: {
                 name: _toStateName,
                 versionID: newVersion.dataValues.id
                 }
                 });
                 }).then((toState) => {
                 _newToState = toState;
                 return meta.model.transition.findOne({
                 where: {
                 fromID: _newFromState.dataValues.id,
                 toID: _newToState.dataValues.id
                 }
                 });
                 }).then((transition) => {

                 meta.action
                 .bindOutputToTransition(row.dataValues.outputID, transition.dataValues.id)
                 .then(() => resolve());

                 });
                 }));
                 }
                 return Promise.all(promises);
                 }).then(() => resolve(newVersion));
                 }).catch((err) => {
                 reject(err);
                 });
                 });
                 */
            }
        }
    };

    meta.model.version.belongsTo(meta.model.fsm, {foreignKey: 'fsmID', constraints: false, onDelete: 'CASCADE'});
    meta.model.state.belongsTo(meta.model.version, {foreignKey: 'versionID', constraints: false, onDelete: 'CASCADE'});
    meta.model.version.belongsTo(meta.model.state, {foreignKey: 'initialStateID', constraints: false});
    meta.model.version.belongsTo(meta.model.version, {
        foreignKey: 'versionParentForkID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.transition.belongsTo(meta.model.state, {
        as: 'transitionFromState',
        foreignKey: 'fromID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.transition.belongsTo(meta.model.state, {
        as: 'transitionToState',
        foreignKey: 'toID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.transitionInput.belongsTo(meta.model.transition, {
        as: 'transitionTransitionInput',
        foreignKey: 'transitionID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.transitionInput.belongsTo(ioCore.model.input, {
        as: 'inputTransitionInput',
        foreignKey: 'inputID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.onTransition.belongsTo(ioCore.model.actionCall, {
        as: 'actionCallOnTransitionFK',
        foreignKey: 'actionCallID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.onTransition.belongsTo(meta.model.transition, {
        as: 'transitionOnTransitionFK',
        foreignKey: 'transitionID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.onTransition.belongsTo(ioCore.model.input, {
        as: 'inputOnTransitionFK',
        foreignKey: 'inputID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.onEnter.belongsTo(meta.model.state, {
        as: 'stateOnEnterFK',
        foreignKey: 'stateID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.onEnter.belongsTo(ioCore.model.actionCall, {
        as: 'actionCallOnEnterFK',
        foreignKey: 'actionCallID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.onExit.belongsTo(meta.model.state, {
        as: 'stateOnExitFK',
        foreignKey: 'stateID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.onExit.belongsTo(ioCore.model.actionCall, {
        as: 'actionCallOnExitFK',
        foreignKey: 'actionCallID',
        constraints: false,
        onDelete: 'CASCADE'
    });

    return meta;

};