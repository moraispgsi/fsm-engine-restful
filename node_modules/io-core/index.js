/**
 * Created by Ricardo Morais on 25/02/2017.
 */
/**
 * Uses the sequelize library to connect to a database using the information given, a database library as to be
 * installed and its type should be sent as the dialect
 *
 * # One of the following libraries will suffice:
 * $ npm install --save pg pg-hstore
 * $ npm install --save mysql2
 * $ npm install --save sqlite3
 * $ npm install --save tedious // MSSQL
 *
 * The dialect should be one of the following
 * dialect: 'mysql'|'sqlite'|'postgres'|'mssql',
 *
 * @param dialect A string representing the database technology 'mysql'|'sqlite'|'postgres'|'mssql'
 * @param host The host of the database
 * @param user The user
 * @param password The user password
 * @param database The name of the database
 * @returns {object} Returns an object which interfaces with the database to provide the io-core functionality
 */
module.exports = function (dialect, host, user, password, database) {
    let co = require('co');
    let Sequelize = require('sequelize');
    let sequelize = new Sequelize(database, user, password, {
        host: host,
        dialect: dialect,
        pool: {
            max: 5,
            min: 0,
            idle: 10000
        },
    });

    let moduleName = 'IOCore';
    let meta = {
        sequelize: sequelize,
        name: moduleName,
        action: {
            /**
             * Create an input
             * @param name The name of the input
             * @returns {Promise} A promise that returns the created input
             */
            createInput: function (name) {
                return meta.model.input.create({
                    name: name
                });
            },
            /**
             * Creates an action
             * @param name The name of the action
             * @param {Array} actionParameters the parameters of the action, an array of object with two properties
             * type(string | number | object | boolean) and name, a string representing the name of the parameter
             * @returns {Promise} Returns a promise
             */
            createAction: function (name, actionParameters) {
                return sequelize.transaction(function (transaction) {
                    return co(function *() {
                        let action = yield meta.model.action.create({
                            name: name
                        }, {transaction: transaction});
                        for (let parameter of actionParameters) {
                            if (parameter.type !== 'string' &&
                                parameter.type !== 'object' &&
                                parameter.type !== 'number' &&
                                parameter.type !== 'boolean' &&
                                parameter.type !== 'any') {
                                throw new Error('Type is not valid');
                            }
                            yield meta.model.parameter.create({
                                actionID: action.dataValues.id,
                                name: parameter.name,
                                type: parameter.type
                            }, {transaction: transaction});
                        }
                        return action;
                    });
                });
            },
            /**
             * Creates an action call which represent a call to an action with specific values. On error the
             * transaction will rollback
             * @param {int} actionID The action to call
             * @param {object} valuesMap An object that maps the action parameter names to values
             * @returns {Promise} Returns a promise
             */
            createActionCall: function (actionID, valuesMap) {
                return sequelize.transaction(function (transaction) {
                    return co(function *() {
                        let actionCall = yield meta.model.actionCall.create({
                            actionID: actionID
                        }, {transaction: transaction});
                        console.log('actionCall', actionCall.dataValues)
                        for (let key of Object.keys(valuesMap)) {
                            let param = (yield meta.model.parameter.findOne({
                                where: {
                                    name: key,
                                    actionID: actionID
                                }
                            }));

                            if (typeof valuesMap[key] !== param.dataValues.type &&
                                    param.dataValues.type !== "any" &&
                                    typeof valuesMap[key] === "function") {
                                throw new Error('Type does not match');
                            }

                            yield meta.model.value.create({
                                parameterID: param.dataValues.id,
                                actionCallID: actionCall.dataValues.id,
                                value: JSON.stringify(valuesMap[key])
                            }, {transaction: transaction});
                        }
                        return actionCall;
                    });
                });
            }
        },
        query: {
            /**
             * Gets an action by id
             * @param {number} actionID The action ID
             * @returns {Promise} Returns a promise that returns an action
             */
            getAction: function (actionID) {
                return co(function*() {
                    try {
                        return yield meta.model.action.findOne({
                            where: {
                                id: actionID
                            }
                        });
                    } catch (error) {
                        throw new Error('Could not get the action');
                    }
                })
            },
            /**
             * Gets the parameters of an action by id
             * @param {integer} actionID The action ID
             * @returns {Promise} Returns a promise that return an array of parameters
             */
            getActionParameters: function (actionID) {
                return co(function*() {
                    try {
                        return yield meta.model.parameter.findAll({
                            where: {
                                actionID: actionID
                            }
                        });
                    } catch (error) {
                        throw new Error('Could not get the parameters');
                    }
                })
            },
            /**
             * Gets an actionCall by ID
             * @param {integer} actionCallID The ID of the actionCall
             * @returns {Promise} Returns a promise that returns an actionCall
             */
            getActionCall: function (actionCallID) {
                return co(function*() {
                    try {
                        return yield meta.model.actionCall.findOne({
                            where: {
                                id: actionCallID
                            }
                        });
                    } catch (error) {
                        throw new Error('Could not get the actionCall');
                    }
                })
            },
            /**
             * Gets the values of an actionCall by ID
             * @param {integer} actionCallID The actionCall ID
             * @returns {Promise} Returns a new Promise return an array of values
             */
            getActionCallValues: function (actionCallID) {
                return co(function*() {
                    try {
                        return yield meta.model.value.findAll({
                            where: {
                                actionCallID: actionCallID
                            }
                        });
                    } catch (error) {
                        throw new Error('Could not get the actionCall values');
                    }
                })
            }
        },
        //io-core database model(the IO core meta-model modeled in the database)
        model: {
            input: sequelize.define(moduleName + 'input', {
                name: {type: Sequelize.STRING, allowNull: false, unique: true},
            }, {
                freezeTableName: true,
                underscoredAll: true
            }),
            action: sequelize.define(moduleName + 'action', {
                name: {type: Sequelize.STRING, allowNull: false, unique: true},
            }, {
                freezeTableName: true,
                underscoredAll: true
            }),
            parameter: sequelize.define(moduleName + 'parameter', {
                name: {type: Sequelize.STRING, allowNull: false, unique: 'parameter'},
                type: {
                    type: Sequelize.DataTypes.ENUM('string', 'number', 'object', 'boolean', 'any'),
                    allowNull: false
                },
                actionID: {type: Sequelize.INTEGER, allowNull: false, unique: 'parameter'},
            }, {
                freezeTableName: true,
                underscoredAll: true
            }),
            actionCall: sequelize.define(moduleName + 'actionCall', {
                actionID: {type: Sequelize.INTEGER, allowNull: false},
            }, {
                freezeTableName: true,
                underscoredAll: true
            }),
            value: sequelize.define(moduleName + 'value', {
                parameterID: {type: Sequelize.INTEGER, allowNull: false, unique: 'value'},
                actionCallID: {type: Sequelize.INTEGER, allowNull: false, unique: 'value'},
                value: {type: Sequelize.TEXT, allowNull: false}
            }, {
                freezeTableName: true,
                underscoredAll: true
            })
        }
    };

    //Relations
    meta.model.parameter.belongsTo(meta.model.action, {
        as: 'actionFK',
        foreignKey: 'actionID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.value.belongsTo(meta.model.actionCall, {
        as: 'actionCallFK',
        foreignKey: 'actionCallID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.value.belongsTo(meta.model.parameter, {
        as: 'parameterFK',
        foreignKey: 'parameterID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    meta.model.actionCall.belongsTo(meta.model.action, {
        as: 'actionFK',
        foreignKey: 'actionID',
        constraints: false,
        onDelete: 'CASCADE'
    });
    return meta;

};